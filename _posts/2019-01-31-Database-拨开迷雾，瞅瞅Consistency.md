---

layout:     post
title:      拨开迷雾，瞅瞅Consistency
subtitle:   我们终于达成“一致”了。
date:       2019-01-31
author:     HD
catalog: true
tags:
     - database
     - transaction
     - ACID
     - Consistency

---

## 正文

### Consistency（一致性）

对于Consistency，很多blog诠释的并不透彻。

精读Concept 后，想谈谈自己关于Consistency的认识。

 

#### C是根本，AID的实现都是为了保证C。

**看看Concept这本书对C的相关描述：**

众所周知，C 代表**一致性**。

这里，我们不妨先看看，何为不一致性。

- Concept 里，对不一致性的描述如下：

> Thus, because of the failure, the state of the system no longer reflects a real state of the world that the database is supposed to capture. We term such a state an inconsistent state.
>
> 由于故障，系统的状态不再反映数据库本应描述的现实世界的真实状态，这便是一种不一致的状态，也就是不一致。

PS：这句话是在原子性的描述下发现的，感觉很符合想表达的。

通过对不一致性的描述，我们可以体会到：ACID中的C，即一致性的标准，是包含着**主观判断**的。这里的主观判断，即我们（或者使用者）是否认为对应的**事务处理** 符合 **我们（或者使用者）所期待的业务逻辑**。

 

若符合，则认为数据处理（或者说业务）是一致的，此次事务处理（业务处理）是成功的。

若不符合，则认为数据处理（或者说业务）是不一致的,此次事务处理（业务处理）是失败的。

 

**即C是根本，是最终的评判标准，是我们要达成的目的——即保证数据（或者业务）从一种被认为正确的状态变为另一种被认为正确的状态的一致性。**

**为了实现C，我们才需要AID即原子性、隔离性、持久性这三个机制的保驾护航。**

 

这样一看，C某种程度上，又可以被看作一种需求，这种需求的实现依赖AID这三个机制。

 

#### 通过Concept里的简单例子，对以上内容做形象化的展示：

![](https://raw.githubusercontent.com/TheFrancisHe/TheFrancisHe.github.io/master/img/consistency.png)

常见的银行转账案例：**A给B转50**，AB分别代表两个银行账户。

 

以此为例，对C-A-I-D 进行逐一梳理，重点突出C。

 

- Consistency

这里的一致性逻辑体现为：转账前后，A减少了50，B增加了50，A+B的金额总和不变。若违反，则认为不一致。

而确保此处**单个事务**一致性逻辑的正确实现，依靠得是程序员所写代码的正确与否，是程序员的责任。

*注：多个事务并发进行，那依靠的数据库的隔离机制了（即多并发的处理机制），程序员只负责将逻辑写对就可以，如果数据库的高并发都让程序员负责的话，那这数据库也就失去了自己特有的价值了，大概是个废软件了。*

另外，这里的一致性，也包含了由数据库使用者所引用的内部约束，如在建表时，引用的**Integrity Constraints**，如非空约束、unique约束、check等。这些一致性逻辑，如果先前设定好了，则DBMS会自动检测。

 

- Atomicity

原子性的概念在这里不赘述。

假设没有实现原子性机制，在Write(A) 和 Write(B) 之间，发生宕机或其他故障。此时，A账户便减少了50，B账户并没有相应的增加50。尽管程序员的写的SQL保证了业务逻辑上的一致性，但由于没有原子性机制的保证，导致这次事务处理并没有从一个正确的状态变为另一个正确的状态，**即没能实现转账前后总额不变这个逻辑一致性**。

- Durability

持久性的概念在这里不赘述。

假设没有实现持久性机制，那么当事务成功地完成后（成功commit了），此时进行了查询，发现此刻符合**一致性的逻辑**，随即发生了故障宕机，故障解除后，却发现刚刚所做的操作全部失效，到头来A账户与B账户也没增加和减少，维持原样，**致使又不符合一致性的逻辑。**

 

- Isolation

隔离性的概念在这里不赘述。

哪怕Atomicity（原子性）和Durability （持久性）都保证了，若隔离性没有保证，则会出现以下情况的发生：

A至B转账过程中，A的总额已经减少了，并Write(A) 成功执行，B也成功完成B+50，但Write(B)并未完成。

此刻事务未提交，同时数据库里又有另外一个并发事务2（一开始那个记作事务1），也在对A和B进行操作。

若无隔离机制，则会读取A与B都未提交的数据（脏数据），假若并发事务2更改了A和B（如A减少了1一个亿，B增加了1块钱），则当事务1完成后，明显会发现，此时A与B账上的钱都乱套了，A账户与B账户的总额也不一致了。

**使又不符合一致性的逻辑**。

 

### 结论：

从以上分析可以得知：

ACID并不是一个level的概念，C（一致性）是根本，C（一致性）的保证依靠A,I,D即数据库原子性、持久性、隔离性的正确实现，这三方面是数据库负责的，与程序员无关。程序员只需要写出符合业务逻辑一致性的SQL（或代码），建表时预设好相应的约束。

**所以Consistency（一致性）的保证需要以下4个条件：**

- DBMS具备原子性机制
- DBMS具备持久性机制
- DBMS具备隔离性机制
- 程序员正确的SQL或逻辑代码

以上四个条件缺一不可。

